---
phase: 02-script-editor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/capabilities/main-window.json
  - src/persistence/types.ts
  - src/persistence/scriptFiles.ts
  - src/persistence/tauriStorage.ts
  - src/stores/scriptStore.ts
  - src/stores/uiStore.ts
autonomous: true

must_haves:
  truths:
    - "Tauri fs and store plugins are registered and functional"
    - "Script and folder types are defined with safe typing"
    - "Scripts can be written to and read from AppData/scripts/ directory"
    - "Metadata (folder structure, script ordering) can be persisted and loaded"
    - "Zustand stores provide reactive state for scripts and UI"
  artifacts:
    - path: "src/persistence/types.ts"
      provides: "Script, ScriptMeta, Folder, AppMetadata type definitions"
      contains: "interface Script"
    - path: "src/persistence/scriptFiles.ts"
      provides: "Filesystem operations for script content (read, write, delete, init)"
      exports: ["saveScriptContent", "loadScriptContent", "deleteScriptFile", "initScriptsDir"]
    - path: "src/persistence/tauriStorage.ts"
      provides: "Custom Zustand storage adapter backed by Tauri store plugin"
      exports: ["tauriJSONStorage"]
    - path: "src/stores/scriptStore.ts"
      provides: "Zustand store for scripts and folders state with persistence"
      exports: ["useScriptStore"]
    - path: "src/stores/uiStore.ts"
      provides: "Zustand store for UI state (sidebar visibility, preview visibility)"
      exports: ["useUIStore"]
    - path: "src-tauri/capabilities/main-window.json"
      provides: "FS and store permissions for main window"
      contains: "fs:allow-write-text-file"
  key_links:
    - from: "src/stores/scriptStore.ts"
      to: "src/persistence/scriptFiles.ts"
      via: "async thunks that save/load script content"
      pattern: "saveScriptContent|loadScriptContent"
    - from: "src/stores/scriptStore.ts"
      to: "src/persistence/tauriStorage.ts"
      via: "Zustand persist middleware for metadata"
      pattern: "tauriJSONStorage"
    - from: "src/persistence/scriptFiles.ts"
      to: "@tauri-apps/plugin-fs"
      via: "Tauri filesystem API"
      pattern: "readTextFile|writeTextFile"
---

<objective>
Install all Phase 2 dependencies, register Tauri plugins, configure filesystem permissions, and build the persistence and state management foundation that all other plans depend on.

Purpose: Every subsequent plan (editor, sidebar, layout) depends on types, stores, and persistence. This foundation must exist first.
Output: Working persistence layer (types, filesystem ops, Tauri storage adapter) and Zustand stores (script state, UI state).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-script-editor/02-CONTEXT.md
@.planning/phases/02-script-editor/02-RESEARCH.md

Source files to understand existing patterns:
@src-tauri/src/lib.rs
@src-tauri/Cargo.toml
@src-tauri/capabilities/main-window.json
@package.json
@vite.config.ts
@src/main/App.tsx
@src/styles/globals.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and register Tauri plugins</name>
  <files>
    package.json
    src-tauri/Cargo.toml
    src-tauri/src/lib.rs
    src-tauri/capabilities/main-window.json
  </files>
  <action>
    1. Install npm dependencies:
       ```
       npm install @uiw/react-codemirror @codemirror/lang-markdown @codemirror/theme-one-dark react-markdown remark-gfm react-resizable-panels @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities @tauri-apps/plugin-fs @tauri-apps/plugin-store zustand
       ```

    2. Add Tauri Rust plugins to src-tauri/Cargo.toml under [dependencies]:
       ```
       tauri-plugin-fs = "2"
       tauri-plugin-store = "2"
       ```

    3. Register plugins in src-tauri/src/lib.rs. Add `.plugin(tauri_plugin_fs::init())` and `.plugin(tauri_plugin_store::Builder::default().build())` to the Builder chain, BEFORE the `.invoke_handler()` call. Do NOT remove any existing plugins or handlers.

    4. Update src-tauri/capabilities/main-window.json to add filesystem and store permissions. Add these to the existing "permissions" array (keep all existing permissions):
       - "fs:default"
       - "fs:allow-read-text-file"
       - "fs:allow-write-text-file"
       - "fs:allow-read-dir"
       - "fs:allow-mkdir"
       - "fs:allow-remove"
       - "fs:allow-rename"
       - "fs:allow-exists"
       - "fs:allow-stat"
       - A scoped fs permission object: { "identifier": "fs:scope", "allow": [{ "path": "$APPDATA" }, { "path": "$APPDATA/**" }] }
       - "store:default"

    Use Context7 to verify the exact Tauri v2 plugin-fs and plugin-store permission identifiers if needed.
  </action>
  <verify>
    - `npm run typecheck` passes (no TS errors from new deps)
    - `npm run clippy` passes (Rust plugins compile and register correctly)
    - New deps appear in package.json and node_modules
    - `tauri-plugin-fs` and `tauri-plugin-store` appear in Cargo.toml
  </verify>
  <done>All dependencies installed, Tauri plugins registered in Rust, filesystem permissions configured. The app builds without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create type definitions and persistence layer</name>
  <files>
    src/persistence/types.ts
    src/persistence/scriptFiles.ts
    src/persistence/tauriStorage.ts
  </files>
  <action>
    1. Create `src/persistence/types.ts` with ABOUTME comment. Define:
       - `Script` interface: { id: string, title: string, content: string, folderId: string, order: number, createdAt: string, updatedAt: string }
       - `ScriptMeta` interface: Same as Script but WITHOUT `content` field (metadata only for persistence)
       - `Folder` interface: { id: string, name: string, order: number, isCollapsed: boolean }
       - `AppMetadata` interface: { folders: Folder[], scripts: ScriptMeta[], activeScriptId: string | null }
       Use string ISO timestamps for createdAt/updatedAt. Use `crypto.randomUUID()` for IDs (no extra dep needed).

    2. Create `src/persistence/scriptFiles.ts` with ABOUTME comment. Implement:
       - `initScriptsDir()`: Calls `mkdir('scripts', { baseDir: BaseDirectory.AppData, recursive: true })` to ensure directory exists. Call this on app startup.
       - `saveScriptContent(id: string, content: string)`: Writes content to `scripts/{id}.md` in AppData.
       - `loadScriptContent(id: string): Promise<string>`: Reads content from `scripts/{id}.md` in AppData. Returns empty string if file does not exist (use `exists()` check first).
       - `deleteScriptFile(id: string)`: Removes `scripts/{id}.md` from AppData. Silently succeeds if file does not exist.
       Import from `@tauri-apps/plugin-fs`: readTextFile, writeTextFile, mkdir, exists, remove, BaseDirectory.

    3. Create `src/persistence/tauriStorage.ts` with ABOUTME comment. Implement a custom Zustand `StateStorage` adapter backed by `@tauri-apps/plugin-store`:
       - Use `load('metadata.json', { autoSave: true })` to get/create the store instance (singleton pattern with module-level variable).
       - Implement `getItem`, `setItem`, `removeItem` as async functions using the Tauri store's `get`, `set`, `delete` methods.
       - Export `tauriJSONStorage` created via `createJSONStorage(() => tauriStorage)`.
       Follow the exact pattern from 02-RESEARCH.md "Custom Zustand Storage Adapter for Tauri Store" section.
  </action>
  <verify>
    - `npm run typecheck` passes
    - All three files exist with correct exports
    - No use of `any` type anywhere
  </verify>
  <done>Type definitions, filesystem persistence, and Tauri storage adapter are implemented with safe typing. All exports match the documented interfaces.</done>
</task>

<task type="auto">
  <name>Task 3: Create Zustand stores for script and UI state</name>
  <files>
    src/stores/scriptStore.ts
    src/stores/uiStore.ts
  </files>
  <action>
    1. Create `src/stores/scriptStore.ts` with ABOUTME comment. Implement a Zustand store using `create` with `persist` middleware:
       - State: `folders: Folder[]`, `scripts: ScriptMeta[]`, `activeScriptId: string | null`, `activeContent: string`, `isLoading: boolean`
       - Actions:
         - `initialize()`: Calls `initScriptsDir()`, then loads content for the active script if one exists. Set `isLoading = false` when done.
         - `createFolder(name: string)`: Creates a new Folder with `crypto.randomUUID()` id, appends to folders array.
         - `createScript(folderId: string, title: string)`: Creates a new ScriptMeta, appends to scripts array, saves empty content via `saveScriptContent`, sets it as active.
         - `deleteFolder(folderId: string)`: Removes folder and all its scripts. Calls `deleteScriptFile` for each script in the folder.
         - `deleteScript(scriptId: string)`: Removes script from array, calls `deleteScriptFile`. If it was active, clear activeScriptId and activeContent.
         - `renameScript(scriptId: string, title: string)`: Updates script title in metadata.
         - `renameFolder(folderId: string, name: string)`: Updates folder name.
         - `setActiveScript(scriptId: string)`: Flush any pending save for the previous script (if debounce is active), load content via `loadScriptContent`, set activeScriptId and activeContent.
         - `setContent(content: string)`: Updates activeContent in memory (debounced save handled in component).
         - `saveActiveContent()`: Saves activeContent to disk via `saveScriptContent` for the activeScriptId. Updates `updatedAt` on the script meta.
         - `reorderScripts(folderId: string, scriptIds: string[])`: Updates order field for scripts in the given folder based on new array order.
         - `moveScript(scriptId: string, targetFolderId: string)`: Moves a script to a different folder, updates its folderId.
       - Persist configuration: Use `tauriJSONStorage` from tauriStorage.ts. Only persist `folders`, `scripts`, and `activeScriptId` (NOT `activeContent` or `isLoading` -- content lives on filesystem). Use the `partialize` option to select which state fields to persist.
       - Name the store 'script-store' for the persist key.

    2. Create `src/stores/uiStore.ts` with ABOUTME comment. Implement a Zustand store using `create` with `persist` middleware:
       - State: `sidebarVisible: boolean` (default true), `previewVisible: boolean` (default false)
       - Actions:
         - `toggleSidebar()`: Flips sidebarVisible
         - `togglePreview()`: Flips previewVisible
         - `setSidebarVisible(visible: boolean)`: Sets directly
         - `setPreviewVisible(visible: boolean)`: Sets directly
       - Persist with `tauriJSONStorage`, name 'ui-store'.

    Both stores must use safe types throughout -- no `any`. Import types from `../persistence/types`.
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run lint` passes
    - Both store files export their hooks (useScriptStore, useUIStore)
    - No `any` types used
    - `npm run check:all` passes (full typecheck + lint + clippy + rust fmt)
  </verify>
  <done>Zustand stores for script state and UI state are implemented with Tauri-backed persistence. Script metadata persists via Tauri store plugin; script content persists via Tauri filesystem plugin. UI preferences (sidebar, preview visibility) persist across restarts.</done>
</task>

</tasks>

<verification>
- `npm run check:all` passes (typecheck + lint + clippy + rust fmt)
- `npm install` succeeded without errors
- All new source files exist: types.ts, scriptFiles.ts, tauriStorage.ts, scriptStore.ts, uiStore.ts
- Tauri plugins registered in lib.rs
- FS permissions configured in main-window.json
</verification>

<success_criteria>
The persistence layer and state management foundation is complete. All subsequent plans can import types from `src/persistence/types.ts`, use filesystem operations from `src/persistence/scriptFiles.ts`, and access reactive state via `useScriptStore` and `useUIStore` hooks. The app builds and runs without errors.
</success_criteria>

<output>
After completion, create `.planning/phases/02-script-editor/02-01-SUMMARY.md`
</output>
