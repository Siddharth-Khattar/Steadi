---
phase: 03-overlay-and-auto-scroll
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/teleprompterStore.ts
  - src-tauri/src/lib.rs
  - src-tauri/capabilities/overlay-window.json
  - src-tauri/capabilities/main-window.json
autonomous: true

must_haves:
  truths:
    - "Teleprompter state (speed preset, font size, opacity, playing status) is managed in a dedicated Zustand store"
    - "Overlay window can receive events emitted from the main window"
    - "Global shortcuts for play/pause and speed cycling are registered and emit events to the overlay"
  artifacts:
    - path: "src/stores/teleprompterStore.ts"
      provides: "Teleprompter-specific Zustand store with persisted preferences and runtime state"
      exports: ["useTeleprompterStore"]
    - path: "src-tauri/src/lib.rs"
      provides: "Extended global shortcut handler dispatching to overlay via emitTo"
      contains: "toggle_play_shortcut"
    - path: "src-tauri/capabilities/overlay-window.json"
      provides: "Event and store permissions for overlay"
      contains: "core:event:default"
    - path: "src-tauri/capabilities/main-window.json"
      provides: "Event and window minimize permissions for main window"
      contains: "core:event:default"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "overlay window"
      via: "app.emit_to('overlay', event)"
      pattern: 'emit_to\("overlay"'
    - from: "src/stores/teleprompterStore.ts"
      to: "src/persistence/tauriStorage.ts"
      via: "Zustand persist middleware with tauriJSONStorage"
      pattern: "tauriJSONStorage"
---

<objective>
Create the teleprompter infrastructure: a dedicated Zustand store for teleprompter state, expand Tauri capabilities for inter-window events, and register global shortcuts in Rust that emit control events to the overlay window.

Purpose: All subsequent plans depend on this communication backbone and state management layer. The store holds preferences that persist across restarts. The Rust shortcuts enable keyboard control from any app. The capabilities enable the overlay to receive events.

Output: teleprompterStore.ts, updated lib.rs with multiple global shortcuts, updated capability files for both windows.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-overlay-and-auto-scroll/03-CONTEXT.md
@.planning/phases/03-overlay-and-auto-scroll/03-RESEARCH.md
@src/stores/scriptStore.ts
@src/stores/uiStore.ts
@src/persistence/tauriStorage.ts
@src-tauri/src/lib.rs
@src-tauri/src/overlay.rs
@src-tauri/capabilities/main-window.json
@src-tauri/capabilities/overlay-window.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create teleprompter Zustand store with persisted preferences</name>
  <files>src/stores/teleprompterStore.ts</files>
  <action>
Create a new Zustand store following the exact pattern from uiStore.ts and scriptStore.ts (persist middleware with tauriJSONStorage).

Interface TeleprompterState (persisted preferences):
- fontSize: number (default 32, range will be 18-64)
- opacity: number (default 0.95, range 0.3-1.0)
- speedPreset: 'slow' | 'medium' | 'fast' (default 'medium')

Interface TeleprompterRuntimeState (NOT persisted):
- isPlaying: boolean (default false)
- scriptContent: string (default '')
- showCountdown: boolean (default false)
- countdownValue: number (default 3)
- scrollProgress: number (default 0, 0-1 for progress bar)

Interface TeleprompterActions:
- togglePlay: () => void -- toggles isPlaying
- setPlaying: (playing: boolean) => void
- cycleSpeed: () => void -- cycles slow->medium->fast->slow
- setScriptContent: (content: string) => void
- startCountdown: () => void -- sets showCountdown true, countdownValue 3
- decrementCountdown: () => void -- decrements countdownValue, if reaches 0: sets showCountdown false and isPlaying true
- setScrollProgress: (progress: number) => void
- increaseFontSize: () => void -- increment by 2, max 64
- decreaseFontSize: () => void -- decrement by 2, min 18
- increaseOpacity: () => void -- increment by 0.05, max 1.0
- decreaseOpacity: () => void -- decrement by 0.05, min 0.3
- resetTeleprompter: () => void -- resets all runtime state to defaults (called when teleprompter stops)

Export speedPreset-to-px/sec mapping as a const:
```typescript
export const SPEED_VALUES: Record<'slow' | 'medium' | 'fast', number> = {
  slow: 40,
  medium: 70,
  fast: 110,
};
```

Use partialize to persist ONLY fontSize, opacity, speedPreset (not runtime state).
Use tauriJSONStorage (import from '../persistence/tauriStorage') with store name 'teleprompter-store'.

Start the file with the standard ABOUTME comment pattern used across the codebase.
  </action>
  <verify>Run `npx tsc -b --noEmit` -- no type errors. Verify the store exports useTeleprompterStore and SPEED_VALUES.</verify>
  <done>teleprompterStore.ts exists with full state, actions, persistence config. Type-checks clean.</done>
</task>

<task type="auto">
  <name>Task 2: Update Tauri capabilities and expand global shortcuts in Rust</name>
  <files>src-tauri/capabilities/overlay-window.json, src-tauri/capabilities/main-window.json, src-tauri/src/lib.rs</files>
  <action>
**Capabilities updates:**

overlay-window.json -- add these permissions alongside existing "core:default":
- "core:event:default" (receive events from main window)
- "store:default" (teleprompter preferences persistence)

main-window.json -- add these permissions alongside existing ones:
- "core:event:default" (emit events to overlay)
- "core:window:allow-minimize" (minimize when teleprompter launches)
- "core:window:allow-set-focus" (focus management)

**Rust global shortcuts expansion (lib.rs):**

The current lib.rs has a single toggle_shortcut (Cmd+Shift+S) with a simple handler. Expand to register multiple shortcuts with a handler that matches each one.

Define these shortcut functions (all left-hand accessible):
- toggle_overlay_shortcut: Cmd+Shift+S (existing, keep as-is)
- toggle_play_shortcut: Cmd+Shift+Space (play/pause teleprompter)
- cycle_speed_shortcut: Cmd+Shift+D (cycle speed presets)
- rewind_shortcut: Cmd+Shift+A (rewind one sentence)
- scroll_up_shortcut: Cmd+Shift+W (manual scroll up)
- scroll_down_shortcut: Cmd+Shift+X (manual scroll down -- X is left-hand accessible, below S/D)

On macOS use SUPER modifier, on Windows/Linux use CONTROL modifier (same pattern as existing toggle_shortcut).

Update the global shortcut handler to match against all shortcuts:
- toggle_overlay -> call overlay::toggle_overlay(app) (existing behavior)
- toggle_play -> app.emit_to("overlay", "teleprompter:toggle-play", ())
- cycle_speed -> app.emit_to("overlay", "teleprompter:cycle-speed", ())
- rewind -> app.emit_to("overlay", "teleprompter:rewind", ())
- scroll_up -> app.emit_to("overlay", "teleprompter:scroll-up", ())
- scroll_down -> app.emit_to("overlay", "teleprompter:scroll-down", ())

For emit_to, use: `app.emit_to("overlay", event_name, ()).ok();`

Import `Manager` trait if not already imported (needed for emit_to). The emit_to method is on the Manager trait.

Register each shortcut individually in the setup closure (after the existing register call pattern). Use `.ok()` on each register call to gracefully handle conflicts, matching the existing error handling pattern but for non-critical shortcuts.

IMPORTANT: The existing `with_handler` closure takes `|app, _shortcut, event|` -- change `_shortcut` to `shortcut` since we now need to match against it. Compare `*shortcut` against each shortcut function result (Shortcut implements PartialEq).
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Projects/Steadi/src-tauri && cargo check` -- no errors.
Verify the capabilities JSON files are valid JSON.
  </verify>
  <done>
Overlay can receive events. Main window can emit events and minimize. Six global shortcuts registered in Rust, each dispatching the appropriate event to the overlay window. cargo check passes cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes (TypeScript)
2. `cd src-tauri && cargo check` passes (Rust)
3. overlay-window.json includes core:event:default and store:default
4. main-window.json includes core:event:default and core:window:allow-minimize
5. lib.rs defines and registers 6 global shortcuts
6. teleprompterStore.ts exports useTeleprompterStore with persist middleware
</verification>

<success_criteria>
- Teleprompter store created with persisted preferences and runtime state
- Both window capability files updated with event permissions
- Rust registers 6 global shortcuts that emit targeted events to the overlay
- All type checks and cargo checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-overlay-and-auto-scroll/03-01-SUMMARY.md`
</output>
