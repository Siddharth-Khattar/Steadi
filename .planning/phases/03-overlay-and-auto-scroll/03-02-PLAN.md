---
phase: 03-overlay-and-auto-scroll
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/overlay/App.tsx
  - src/overlay/components/TeleprompterView.tsx
  - src/overlay/components/Countdown.tsx
  - src/overlay/components/ProgressBar.tsx
  - src/overlay/hooks/useAutoScroll.ts
  - src/overlay/hooks/useOverlayEvents.ts
  - src/styles/globals.css
autonomous: true

must_haves:
  truths:
    - "Overlay displays the active script's markdown content rendered with bold, headers, emphasis, and bullet lists"
    - "A 3-2-1 countdown appears over the dimmed script before scrolling begins"
    - "Script scrolls smoothly upward at a constant speed determined by the active speed preset"
    - "Already-read text fades out at the top edge of the overlay"
    - "A thin progress bar at the bottom edge fills left-to-right as the script progresses"
    - "The current reading area has a subtle highlight to guide the eye"
  artifacts:
    - path: "src/overlay/App.tsx"
      provides: "Overlay root rewritten to host TeleprompterView, Countdown, and event listeners"
      min_lines: 30
    - path: "src/overlay/components/TeleprompterView.tsx"
      provides: "Scrolling markdown container with fade effect and current-line highlight"
      min_lines: 50
    - path: "src/overlay/components/Countdown.tsx"
      provides: "3-2-1 countdown overlay component"
      min_lines: 20
    - path: "src/overlay/components/ProgressBar.tsx"
      provides: "Bottom-edge progress bar"
      min_lines: 10
    - path: "src/overlay/hooks/useAutoScroll.ts"
      provides: "requestAnimationFrame-based continuous scroll engine"
      min_lines: 40
    - path: "src/overlay/hooks/useOverlayEvents.ts"
      provides: "Tauri event listeners for inter-window communication"
      min_lines: 30
  key_links:
    - from: "src/overlay/hooks/useOverlayEvents.ts"
      to: "src/stores/teleprompterStore.ts"
      via: "Event listeners call store actions (setScriptContent, togglePlay, cycleSpeed)"
      pattern: "useTeleprompterStore"
    - from: "src/overlay/hooks/useAutoScroll.ts"
      to: "src/overlay/components/TeleprompterView.tsx"
      via: "Hook drives scrollTop of the container ref"
      pattern: "containerRef"
    - from: "src/overlay/components/TeleprompterView.tsx"
      to: "react-markdown"
      via: "Renders script content as markdown with styled components"
      pattern: "ReactMarkdown"
---

<objective>
Build the teleprompter overlay UI: rewrite the static overlay into a fully functional teleprompter with markdown rendering, a countdown timer, a smooth requestAnimationFrame scroll engine, and visual polish (top fade, progress bar, reading-line highlight).

Purpose: This is the core visual experience -- when the user clicks "Start Teleprompter", they see their script rendered beautifully, preceded by a countdown, then smoothly scrolling upward. This plan focuses entirely on the overlay window's rendering and scroll mechanics.

Output: Rewritten overlay/App.tsx, 3 new components, 2 new hooks, updated globals.css.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-overlay-and-auto-scroll/03-CONTEXT.md
@.planning/phases/03-overlay-and-auto-scroll/03-RESEARCH.md
@.planning/phases/03-overlay-and-auto-scroll/03-01-SUMMARY.md
@src/overlay/App.tsx
@src/overlay/main.tsx
@src/components/preview/MarkdownPreview.tsx
@src/stores/teleprompterStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scroll engine hook and overlay event listener hook</name>
  <files>src/overlay/hooks/useAutoScroll.ts, src/overlay/hooks/useOverlayEvents.ts</files>
  <action>
**useAutoScroll.ts:**

Create a custom hook that drives smooth continuous scrolling using requestAnimationFrame with time-delta-based position updates. This is the core teleprompter scroll mechanism.

Parameters:
- containerRef: React.RefObject<HTMLDivElement | null>
- speedPxPerSec: number
- isPlaying: boolean

Returns: { scrollProgress: number, setScrollPosition: (pos: number) => void, getScrollPosition: () => number }

Implementation details:
- Use performance.now() time-delta calculation: `distance = speed * (now - lastTime) / 1000`
- Store scroll position in a ref (NOT state) to avoid 60 re-renders/second
- Set container.scrollTop directly for performance
- Clamp to maxScroll (container.scrollHeight - container.clientHeight)
- Stop silently at end of script (don't loop, don't auto-close)
- When isPlaying transitions from true to false, cancel the animation frame
- When isPlaying transitions from false to true, reset lastTimeRef to performance.now() to avoid a time-delta jump
- scrollProgress (0 to 1) should update the teleprompter store via setScrollProgress, but throttled (every ~200ms, not every frame)
- Expose setScrollPosition for rewind functionality (sets both the ref and scrollTop)
- Expose getScrollPosition for reading current position

IMPORTANT anti-pattern: Do NOT use CSS scroll-behavior: smooth. Do NOT use setInterval. Do NOT store scrollTop in React state.

**useOverlayEvents.ts:**

Create a hook that listens for Tauri events from the main window and routes them to the teleprompterStore.

On mount, register listeners for:
- 'teleprompter:load-script' (payload: { content: string }) -> store.setScriptContent(payload.content)
- 'teleprompter:start-countdown' (no payload) -> store.startCountdown()
- 'teleprompter:toggle-play' (no payload) -> store.togglePlay()
- 'teleprompter:cycle-speed' (no payload) -> store.cycleSpeed()
- 'teleprompter:rewind' (no payload) -> handled in Plan 04 (for now, no-op or emit to a callback)
- 'teleprompter:scroll-up' (no payload) -> scroll callback (passed as parameter)
- 'teleprompter:scroll-down' (no payload) -> scroll callback (passed as parameter)

Import listen from '@tauri-apps/api/event'.

Parameters: { onRewind: () => void, onScrollUp: () => void, onScrollDown: () => void }

Cleanup: return unlisten functions in useEffect cleanup (each listen() returns a Promise<UnlistenFn>; collect them and call each in cleanup).

Use the same cleanup pattern as shown in the research:
```typescript
return () => {
  listeners.forEach(p => p.then(fn => fn()));
};
```

Start both files with ABOUTME comments.
  </action>
  <verify>Run `npx tsc -b --noEmit` -- no type errors.</verify>
  <done>useAutoScroll drives smooth rAF scrolling with time-delta. useOverlayEvents bridges Tauri events to teleprompter store actions. Both type-check clean.</done>
</task>

<task type="auto">
  <name>Task 2: Create overlay components and rewrite overlay App.tsx</name>
  <files>src/overlay/components/TeleprompterView.tsx, src/overlay/components/Countdown.tsx, src/overlay/components/ProgressBar.tsx, src/overlay/App.tsx, src/styles/globals.css</files>
  <action>
**Countdown.tsx:**

A full-screen overlay showing 3, 2, 1 countdown numbers. The script text is visible but dimmed underneath.

Props: { onComplete: () => void }
- Uses useState for count (starts at 3)
- Uses useEffect with setTimeout to decrement every 1000ms
- When count reaches 0, calls onComplete() and returns null
- Large centered number (text-7xl or similar), white/90, tabular-nums for consistent width
- The component overlays on top of the content (absolute inset-0, z-50, flex center)
- Subtle scale animation on each number change (CSS transition or simple className toggle)

**ProgressBar.tsx:**

A thin bar at the absolute bottom of the overlay.

Props: { progress: number } (0 to 1)
- Absolutely positioned at bottom: 0, left: 0, full width container
- Height: 3px (thin and subtle)
- Background fill: white/40, width set as percentage of progress
- Smooth width transition (transition: width 200ms linear)
- If progress is 0, render nothing (avoid a 0-width bar flash)

**TeleprompterView.tsx:**

The main scrolling content area. Renders markdown and applies visual effects.

Props: { containerRef: React.RefObject<HTMLDivElement | null> }
- Reads scriptContent, fontSize, opacity from useTeleprompterStore
- Renders scriptContent using react-markdown (import ReactMarkdown from 'react-markdown') with remark-gfm plugin
- Use the react-markdown `components` prop to style elements for the overlay context:
  - h1: text-[1.4em] font-bold text-white/95 mb-4
  - h2: text-[1.2em] font-bold text-white/90 mb-3
  - h3: text-[1.1em] font-semibold text-white/85 mb-2
  - p: mb-4 leading-relaxed (inherits text color from parent)
  - strong: text-white font-semibold (brighter than body)
  - em: text-white/80 italic
  - ul: list-disc list-inside mb-4 space-y-1
  - li: (no special styling, inherits)
- The container div has the ref passed as containerRef
- Container div: overflow-y-auto (scrollable), flex-1, padding for readability (px-8 py-6)
- Apply CSS mask-image for top-edge fade effect via className (defined in globals.css)
- Text color: text-white/85 (soft white body text)
- Font size applied via inline style: `style={{ fontSize: ${fontSize}px }}`
- NO visible scrollbar: use Tailwind's scrollbar-hide or CSS ::-webkit-scrollbar { display: none }

**Current reading line highlight:**
Add a visual guide for the current reading position. Use a subtle gradient overlay at roughly 30-35% from the top of the container (the "reading zone"). This can be a fixed pseudo-element or a separate positioned div:
- A thin horizontal band (about 2em tall) with a very faint white/5 background
- Positioned at ~30% from the top of the visible area
- This is a STATIC visual guide (does not track specific lines) -- it highlights the area where the user's eye naturally reads as text scrolls through

**globals.css additions:**
```css
/* Teleprompter top-edge fade */
.teleprompter-fade {
  mask-image: linear-gradient(
    to bottom,
    transparent 0%,
    black 12%,
    black 100%
  );
  -webkit-mask-image: linear-gradient(
    to bottom,
    transparent 0%,
    black 12%,
    black 100%
  );
}

/* Hide scrollbar in teleprompter */
.teleprompter-scroll::-webkit-scrollbar {
  display: none;
}
```

**overlay/App.tsx rewrite:**

Replace the entire static content with the teleprompter application:
- Import and use useOverlayEvents hook (pass callbacks for rewind/scroll-up/scroll-down)
- Import and use useAutoScroll hook (with container ref, speed from store, isPlaying from store)
- Read state from useTeleprompterStore: isPlaying, showCountdown, scriptContent, scrollProgress, speedPreset, opacity
- Import SPEED_VALUES from teleprompterStore to convert speedPreset to px/sec
- Use a ref for the scroll container (passed to TeleprompterView and useAutoScroll)

Layout structure:
```
<div className="w-full h-full flex flex-col overflow-hidden bg-black" style={{ opacity }}>
  {/* Reading line highlight guide */}
  <div className="absolute left-0 right-0 top-[30%] h-[2em] bg-white/[0.03] pointer-events-none z-10" />

  {scriptContent ? (
    <>
      <TeleprompterView containerRef={scrollContainerRef} />
      <ProgressBar progress={scrollProgress} />
      {showCountdown && (
        <Countdown onComplete={() => { /* store.setPlaying(true) is handled by decrementCountdown reaching 0 */ }} />
      )}
    </>
  ) : (
    <div className="flex-1 flex items-center justify-center">
      <p className="text-white/30 text-lg">No script loaded</p>
    </div>
  )}
</div>
```

For the rewind callback: implement a simple version that scrolls back by a fixed amount (e.g., 150px animated). The sentence-level rewind will be refined in Plan 04 if needed, but a basic implementation here:
```typescript
const handleRewind = () => {
  const current = scrollEngine.getScrollPosition();
  scrollEngine.setScrollPosition(Math.max(0, current - 150));
};
```

For scroll-up/scroll-down manual callbacks: scroll by ~80px in the respective direction.

Keep the ABOUTME comment at the top of overlay/App.tsx. Update the description to reflect the teleprompter functionality.

Start all new component files with ABOUTME comments.
  </action>
  <verify>
Run `npx tsc -b --noEmit` -- no type errors.
Run `npm run build` (or equivalent) to verify Vite bundles the overlay entry point without errors.
  </verify>
  <done>
Overlay shows rendered markdown content with fade effect, countdown timer, progress bar, and reading-line highlight. The scroll engine drives smooth upward scrolling via requestAnimationFrame. Events from main window are received and routed to the store. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes
2. `npm run build` succeeds (Vite bundles overlay entry point)
3. overlay/App.tsx imports and uses TeleprompterView, Countdown, ProgressBar
4. useAutoScroll uses requestAnimationFrame with time-delta (not setInterval, not CSS animation)
5. useOverlayEvents listens for all teleprompter events from Tauri
6. TeleprompterView renders markdown via react-markdown with styled components
7. globals.css includes teleprompter-fade mask-image and scrollbar-hide rules
</verification>

<success_criteria>
- Overlay displays "No script loaded" when empty, rendered markdown when content is loaded via events
- Countdown displays 3-2-1 over dimmed content, then disappears and scrolling starts
- Scroll is smooth, continuous, and driven by rAF with time-delta
- Top-edge fade, progress bar, and reading-line highlight are visible
- No type errors, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-overlay-and-auto-scroll/03-02-SUMMARY.md`
</output>
