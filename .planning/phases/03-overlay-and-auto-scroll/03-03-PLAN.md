---
phase: 03-overlay-and-auto-scroll
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/toolbar/TopBar.tsx
  - src/main/App.tsx
  - src-tauri/src/overlay.rs
autonomous: true

must_haves:
  truths:
    - "Clicking 'Start Teleprompter' in the editor sends the active script to the overlay and minimizes the editor window"
    - "User can drag the overlay to any position on screen"
    - "User can resize the overlay by dragging its edges or corners"
    - "Overlay position and size persist across app restarts"
  artifacts:
    - path: "src/components/toolbar/TopBar.tsx"
      provides: "Functional Start Teleprompter button that emits events and minimizes main window"
      contains: "emitTo"
    - path: "src-tauri/src/overlay.rs"
      provides: "Overlay window with resizable(true) and initial geometry restored from persisted state"
      contains: "resizable(true)"
  key_links:
    - from: "src/components/toolbar/TopBar.tsx"
      to: "overlay window"
      via: "emitTo('overlay', 'teleprompter:load-script') and emitTo('overlay', 'teleprompter:start-countdown')"
      pattern: "emitTo.*overlay.*load-script"
    - from: "src/components/toolbar/TopBar.tsx"
      to: "main window minimize"
      via: "getCurrentWindow().minimize()"
      pattern: "minimize"
---

<objective>
Wire the "Start Teleprompter" button to launch the teleprompter flow, make the overlay window draggable and resizable, and persist overlay geometry across restarts.

Purpose: This makes the teleprompter launchable from the editor and gives users full control over overlay placement and size. Without this, the overlay is stuck at its default position and size with no way to launch it from the editor UI.

Output: Updated TopBar.tsx with functional launch button, updated overlay.rs with resize support, overlay drag/resize handling in the frontend.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-overlay-and-auto-scroll/03-CONTEXT.md
@.planning/phases/03-overlay-and-auto-scroll/03-RESEARCH.md
@.planning/phases/03-overlay-and-auto-scroll/03-01-SUMMARY.md
@src/components/toolbar/TopBar.tsx
@src/main/App.tsx
@src/stores/scriptStore.ts
@src-tauri/src/overlay.rs
@src-tauri/capabilities/main-window.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Start Teleprompter button in TopBar</name>
  <files>src/components/toolbar/TopBar.tsx, src/main/App.tsx</files>
  <action>
**TopBar.tsx updates:**

Replace the disabled "Start Teleprompter" placeholder button with a functional one.

Import:
- `emitTo` from '@tauri-apps/api/event'
- `getCurrentWindow` from '@tauri-apps/api/window'
- `useScriptStore` from '../../stores/scriptStore'

Create an async handler `startTeleprompter`:
1. Get activeContent and activeScriptId from useScriptStore.getState()
2. If no activeContent or no activeScriptId, return early (button should be disabled when no script is open, but guard anyway)
3. Save current content first: `await useScriptStore.getState().saveActiveContent()`
4. Emit load-script event: `await emitTo('overlay', 'teleprompter:load-script', { content: activeContent })`
5. Emit start-countdown event: `await emitTo('overlay', 'teleprompter:start-countdown', {})`
6. Minimize main window: `await getCurrentWindow().minimize()`

Button styling: Change from disabled/gray to an active button. Use a distinct style to make it prominent:
- Background: bg-white/10 hover:bg-white/15
- Text: text-white/90
- Remove the `disabled` attribute
- Add onClick={startTeleprompter}
- Conditionally disable (visually and functionally) when no activeScriptId: use useScriptStore to read activeScriptId, if null, keep the disabled styling

Also update the button label from "Start Teleprompter" to "Start" (shorter, cleaner in the toolbar).

Wrap the handler in a try/catch that logs errors to console (emitTo may fail if overlay window doesn't exist).

**App.tsx minor update (main window):**

The main App.tsx may need to ensure the script store initializes. Check if `useScriptStore.getState().initialize()` is already called on mount. If it is (it should be from Phase 2), no change needed. If not, add a useEffect that calls initialize() on mount.

No other changes to App.tsx unless needed for the Start button functionality.
  </action>
  <verify>Run `npx tsc -b --noEmit` -- no type errors. Verify TopBar imports emitTo and getCurrentWindow.</verify>
  <done>"Start" button in TopBar emits load-script and start-countdown events to overlay, then minimizes main window. Disabled when no script is active. Type-checks clean.</done>
</task>

<task type="auto">
  <name>Task 2: Make overlay draggable, resizable, and persist geometry</name>
  <files>src-tauri/src/overlay.rs, src/overlay/App.tsx</files>
  <action>
**overlay.rs changes:**

1. Change `.resizable(false)` to `.resizable(true)` in create_overlay. This allows the window to be resized.

2. Add a `restore_overlay_geometry` concept: Before creating the overlay, check if there's a saved position/size. However, since the overlay preferences are stored via the frontend Tauri store (not accessible from Rust easily), the simpler approach is:
   - Create the overlay at the default position/size (current behavior)
   - Let the frontend restore geometry on mount (via useEffect that reads from the teleprompter store and calls window APIs)

So the Rust change is minimal: just flip resizable to true. Keep everything else as-is.

**Overlay App.tsx additions (drag + resize + persist):**

NOTE: This plan touches overlay/App.tsx for drag/resize zone additions ONLY. The teleprompter UI components are being built in parallel by Plan 02. Since these plans run in Wave 2 simultaneously, this plan should add drag/resize functionality in a way that can be merged cleanly.

The approach: Add a SEPARATE component file for the resize/drag zone handling.

Create `src/overlay/components/WindowControls.tsx` (new file):

This component provides invisible edge zones for resize-dragging AND a drag zone for moving the window.

For RESIZE:
- Render invisible edge zones (6px strips) at all 4 edges and 4 corners of the window
- On mousedown in an edge zone, call `getCurrentWindow().startResizeDragging(direction)` with the appropriate ResizeDirection string
- The ResizeDirection values are: 'East', 'West', 'North', 'South', 'NorthEast', 'NorthWest', 'SouthEast', 'SouthWest'
- Edge zones should be absolutely positioned with high z-index (z-50) so they're above content
- Set appropriate cursors: col-resize for E/W, row-resize for N/S, corner resize cursors for corners

For DRAG:
- The remaining area (not edges, not the scroll content) should allow window dragging
- Use `data-tauri-drag-region` attribute on a drag-handle area
- The best approach: add `data-tauri-drag-region` to a thin top strip of the overlay (top 20px or so) that acts as a grab handle. This avoids conflicts with scrolling content.
- Alternatively, use `getCurrentWindow().startDragging()` on mousedown in a designated area.

For GEOMETRY PERSISTENCE:
- Listen to window move and resize events using onMoved and onResized from '@tauri-apps/api/window'
- Debounce saves (300ms) to avoid disk thrash during active dragging
- Save to Tauri store via a direct store.set call (import load from '@tauri-apps/plugin-store')
- Storage key: 'overlay-geometry' with value: { x, y, width, height }
- Convert physical pixels to logical using scaleFactor: `pos.toLogical(scale)`, `size.toLogical(scale)`
- On mount, restore geometry: read 'overlay-geometry' from store, if exists, call `getCurrentWindow().setPosition()` and `getCurrentWindow().setSize()`
- Use LogicalPosition and LogicalSize classes from '@tauri-apps/api/dpi'

Create a hook `src/overlay/hooks/useOverlayGeometry.ts`:
- On mount: load saved geometry from Tauri store, apply to window
- Register onMoved and onResized listeners with debounced save
- Cleanup listeners on unmount

Then in overlay/App.tsx, add:
1. Import and render WindowControls component (absolute positioned, covers full window)
2. Call useOverlayGeometry hook

IMPORTANT: Since Plan 02 is rewriting App.tsx simultaneously, keep these additions minimal and isolated. The WindowControls component and useOverlayGeometry hook are self-contained. If Plan 02 completes first, the additions from this plan are just: import WindowControls, render it, call useOverlayGeometry. If this plan completes first, Plan 02's rewrite should incorporate these components.

To handle the parallel execution gracefully: create WindowControls.tsx and useOverlayGeometry.ts as standalone files. Add a comment in the current overlay/App.tsx noting where they should be integrated:

```typescript
// TODO(03-03): Import and use WindowControls and useOverlayGeometry
// These provide drag/resize zones and geometry persistence
```

If overlay/App.tsx has already been rewritten by Plan 02, integrate directly into the new structure instead.

Start all new files with ABOUTME comments.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Projects/Steadi/src-tauri && cargo check` -- no errors (overlay.rs change).
Run `npx tsc -b --noEmit` -- no type errors.
  </verify>
  <done>
Overlay window is resizable (Rust). WindowControls component provides invisible edge/corner resize handles and a top drag strip. useOverlayGeometry persists position and size to Tauri store and restores on mount. TopBar "Start" button sends script to overlay and minimizes editor.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes
2. `cd src-tauri && cargo check` passes
3. TopBar "Start" button calls emitTo with load-script and start-countdown
4. overlay.rs has resizable(true)
5. WindowControls renders resize edge zones with startResizeDragging
6. useOverlayGeometry saves and restores position/size from Tauri store
</verification>

<success_criteria>
- "Start" button in editor sends active script to overlay and minimizes the editor
- Overlay can be resized by dragging edges/corners
- Overlay can be dragged to any position via a top grab strip
- Position and size persist across app restarts (saved to Tauri store, restored on mount)
- Type checks and cargo checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-overlay-and-auto-scroll/03-03-SUMMARY.md`
</output>
